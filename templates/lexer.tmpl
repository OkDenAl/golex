// Code generated by golex utility; DO NOT EDIT.
package golexgen

import (
	"fmt"
)

type ErrHandler interface {
	Error(msg string, pos Position, symbol string)
}

type (
    ErrFunc func (msg string, pos Position, symbol string)
    SwitchConditionFunc func (cond Condition)
)

type Continued bool

type LexemHandler interface {
	ErrHandler
    {{ range .AllRegexps }}{{ .ActionName }}(text string, start, end Position, errFunc ErrFunc, switchCond SwitchConditionFunc) (Token, Continued)
    {{ end }}
}

type Tag interface {
	GetTag() string
}

const EOP = "EOP"

type Condition int
const (
   dummy = Condition(iota)
{{ range $key, $value := .Conditions }}
   Condition{{ $key }}{{ end }}
)

type DefaultTag int
const (
	TagErr DefaultTag = iota
	{{ range .AllRegexps }}Tag{{ .ActionName }}
    {{ end }}{{ range $key, $value := .Conditions }}Tag{{ $key }}
    {{ end }}
)

func (t DefaultTag) GetTag() string {
	var tagToString = map[DefaultTag]string{
	    {{ range .AllRegexps }}Tag{{ .ActionName }}: "{{ .ActionName }}",
	    {{ end }}{{ range $key, $value := .Conditions }}Tag{{ $key }}: "{{ $key }}",
	    {{ end }}
	}

	return tagToString[t]
}

type FiniteState struct {
	NextState      int
	CurrentState   int
	TerminalStates []TerminalState
	Transitions    map[int]map[rune]int
}

type TerminalState struct {
	state     int
	lexemName string
}

func (f *FiniteState) FindLexemOneAutomata(pos Position) (string, string, Position) {
	f.CurrentState = 0
	prevWord := ""
	prevStr := ""
	curWord := ""
	var prevResPos Position
	for pos.cp() != -1 {
		ch := rune(pos.cp())
		if !f.canMoveBy(ch) {
			break
		}
		curWord += string(ch)

		if val, ok := f.isTerminalOneAutomata(f.CurrentState); ok {
			prevResPos=pos
			prevWord = curWord
			prevStr = val.lexemName
		}

		pos.next()
	}

	return prevWord, prevStr,prevResPos
}

func (f *FiniteState) canMoveBy(ch rune) bool {
	from := f.CurrentState
	if to, ok := f.Transitions[from][ch]; ok {
		f.CurrentState = to
		return true
	}

	return false
}

func (f *FiniteState) isTerminalOneAutomata(state int) (TerminalState, bool) {
	for _, val := range f.TerminalStates {
		if state == val.state {
			return val, true
		}
	}
	return TerminalState{}, false
}

func (f *FiniteState) isTerminal(state int) bool {
	for _, val := range f.TerminalStates {
		if state == val.state {
			return true
		}
	}
	return false
}

var(
    {{ range .AllRegexps }}automata{{ .ActionName }} *FiniteState = &FiniteState{
    CurrentState:  {{ .RegexpVal.CurrentState }},
    TerminalStates: []TerminalState{ {{ range .RegexpVal.TerminalStates }}{state: {{.State}}, lexemName: "{{.LexemName}}" }, {{ end }}},
    Transitions: map[int]map[rune]int{
            {{ range $key, $value := .RegexpVal.Transitions }}{{ $key }}: { {{ range $char, $nextState := $value }}{{ $char }}: {{ $nextState }},{{ end }}},
            {{ end }}
        },
        }
    {{ end }}

    {{ range .UnionRegexps }}unionAutomata{{ .ActionName }} *FiniteState = &FiniteState{
        CurrentState:  {{ .RegexpVal.CurrentState }},
        TerminalStates: []TerminalState{ {{ range .RegexpVal.TerminalStates }}{state: {{.State}}, lexemName: "{{.LexemName}}" }, {{ end }}},
        Transitions: map[int]map[rune]int{
                {{ range $key, $value := .RegexpVal.Transitions }}{{ $key }}: { {{ range $char, $nextState := $value }}{{ $char }}: {{ $nextState }},{{ end }}},
                {{ end }}
            },
            }
        {{ end }}
)

type HandlerBase struct{}

func (e *HandlerBase) Error(msg string, pos Position, symbol string) {
	fmt.Printf("ERROR%s: %s %s\n",pos.String(),msg, symbol)
}

{{ range .AllRegexps }}func (h *HandlerBase){{ .ActionName }}(
    text string,
    start, end Position,
    errFunc ErrFunc,
    switchCond SwitchConditionFunc,
) (Token,Continued) {
    {{ if .SwitchConditionName }}switchCond(Condition{{ .SwitchConditionName }})

        {{ if .Continued }}return Token{},{{ .Continued }}
        }
        {{ else }} return NewToken(Tag{{ .ActionName }},start,end,text), {{ .Continued }}
        }{{ end }}
    {{ else}}{{ if .Continued }}return Token{},{{ .Continued }}
        }
        {{ else }} return NewToken(Tag{{ .ActionName }},start,end,text), {{ .Continued }}
        }{{ end }}
    {{end}}
{{ end }}

type EOPTag struct{}

func (e EOPTag) GetTag() string {
	return EOP
}

type Token struct {
	tag    Tag
	coords fragment
	val    string
}

func NewToken(tag Tag, starting, following Position, val string) Token {
	return Token{tag: tag, coords: newFragment(starting, following), val: val}
}

func (t Token) String() string {
	return fmt.Sprintf("%s %s: %s", t.tag.GetTag(), t.coords, t.val)
}

func (t Token) Tag() string {
	return t.tag.GetTag()
}

type fragment struct {
	starting  Position
	following Position
}

func newFragment(starting, following Position) fragment {
	return fragment{starting: starting, following: following}
}

func (f fragment) String() string {
	return fmt.Sprintf("%s-%s", f.starting.String(), f.following.String())
}

type position struct {
	symb rune
	line int
	pos  int
}

func newPosition(symb rune) position {
	return position{symb: symb, line: 1, pos: 1}
}

type Position struct {
	position
	reader bufio.Reader
}

func NewPosition(reader bufio.Reader) Position {
	r, _, err := reader.ReadRune()
	if err != nil {
		r = -1
	}
	return Position{position: newPosition(r), reader: reader}
}

func (p *Position) String() string {
	return fmt.Sprintf("(%d,%d)", p.line, p.pos)
}

func (p *Position) cp() int {
	return int(p.symb)
}

func (p *Position) isNewLine() bool {
	return p.cp() == '\n'
}

func (p *Position) next() Position {
	r, _, err := p.reader.ReadRune()
	if err == nil {
		if p.isNewLine() {
			p.line++
			p.pos = 1
		} else {
			p.pos++
		}
		p.symb = r
	} else {
		p.symb = -1
	}

	return *p
}

type Scanner struct {
	programReader bufio.Reader
	handler LexemHandler
	regexps map[Condition][]*FiniteState
	unionRegexps map[Condition]*FiniteState
	curPos  Position

	curCondition Condition
}

func NewScanner(programFile bufio.Reader, handler LexemHandler) Scanner {
    regexps := make(map[Condition][]*FiniteState)
    {{ range $key, $value := .Conditions }}
       regexps[Condition{{ $key }}]=make([]*FiniteState,0, {{ $value.RegexpsLen }})
       {{ range $value.Regexps }}regexps[Condition{{ $key }}] = append(regexps[Condition{{ $key }}], automata{{ .ActionName }})
        {{ end }}
    {{ end }}

    unionRegexps := make(map[Condition]*FiniteState)
    {{ range $key, $value := .Conditions }}
       unionRegexps[Condition{{ $key }}] = unionAutomata{{ $key }}
    {{ end }}


	return Scanner{
		programReader:      programFile,
		handler:      handler,
		regexps:      regexps,
		unionRegexps: unionRegexps,
		curPos:       NewPosition(programFile),
		curCondition: ConditionINIT,
	}
}

func (s *Scanner) switchCondition(cond Condition) {
    s.curCondition = cond
}

func (s *Scanner) findTokenOneAutomata(
    curWord string,
    name string,
    start, end Position,
    errFunc ErrFunc,
    switchCond SwitchConditionFunc,
) (Token, Continued) {
    switch s.curCondition{
    {{ range $key, $value := .Conditions }} case Condition{{ $key }}: return s.findTokenOneAutomata{{ $key }}(curWord,name,start,end,errFunc, switchCond)
    {{ end }}}

	return Token{}, true
}

{{ range $key, $value := .Conditions }}
func (s *Scanner) findTokenOneAutomata{{ $key }}(
    curWord string,
    name string,
    start, end Position,
    errFunc ErrFunc,
    switchCond SwitchConditionFunc,
) (Token, Continued) {
	switch name {
    {{ range $value.Regexps }}case "{{ .ActionName }}": return s.handler.{{ .ActionName }}(curWord, start, end, errFunc, switchCond)
    {{ end }}}

	return Token{}, true
}
{{ end }}


func (s *Scanner) findToken(
    curWord string,
    automata *FiniteState,
    start, end Position,
    errFunc ErrFunc,
    switchCond SwitchConditionFunc,
) (Token, Continued) {
    switch s.curCondition{
    {{ range $key, $value := .Conditions }} case Condition{{ $key }}: return s.findToken{{ $key }}(curWord, automata,start,end,errFunc, switchCond)
    {{ end }}}

	return Token{}, true
}

{{ range $key, $value := .Conditions }}
func (s *Scanner) findToken{{ $key }}(
    curWord string,
    automata *FiniteState,
    start, end Position,
    errFunc ErrFunc,
    switchCond SwitchConditionFunc,
) (Token, Continued) {
	switch automata {
    {{ range $value.Regexps }}case automata{{ .ActionName }}: return s.handler.{{ .ActionName }}(curWord, start, end, errFunc, switchCond)
    {{ end }}}

	return Token{}, true
}
{{ end }}

func (s *Scanner) NextTokenOneAutomata() Token {
	for s.curPos.cp() != -1 {
		startPos := s.curPos
		res, name, pos := s.unionRegexps[s.curCondition].FindLexemOneAutomata(s.curPos)
		s.curPos=pos
		s.curPos.next()

		if len(name) == 0 {
			if s.curPos.cp() != -1 {
				s.curPos.next()
			} else {
				break
			}
			s.handler.Error("ERROR: unknown symbol", startPos, string(s.curPos.cp()))
		} else {
			tok, continued := s.findTokenOneAutomata(res, name, startPos, pos, s.handler.Error, s.switchCondition)
			if !continued {
				return tok
			}
		}
	}

	return NewToken(EOPTag{}, s.curPos, s.curPos, "")
}
