// Code generated by golex utility;
// This code is present a default handling of tokens;
// YOU CAN EDIT IT IF YOU NEED.
package main

import (
	"fmt"
	"golex/examples/lab1.2/golexgen"
	"os"
)

type Handler struct {
	golexgen.ErrHandlerBase
}

func (h *Handler) Skip(
	text []rune,
	start, end golexgen.Position,
	errFunc golexgen.ErrFunc,
	switchCond golexgen.SwitchConditionFunc,
) (golexgen.Token, golexgen.Continued) {
	return golexgen.NewToken(
		golexgen.TagSkip,
		start, end,
		string(text[start.Index():end.Index()]),
	), true
}

func (h *Handler) Assembly(
	text []rune,
	start, end golexgen.Position,
	errFunc golexgen.ErrFunc,
	switchCond golexgen.SwitchConditionFunc,
) (golexgen.Token, golexgen.Continued) {
	return golexgen.NewToken(
		golexgen.TagAssembly,
		start, end,
		string(text[start.Index():end.Index()]),
	), false
}

func (h *Handler) Ident(
	text []rune,
	start, end golexgen.Position,
	errFunc golexgen.ErrFunc,
	switchCond golexgen.SwitchConditionFunc,
) (golexgen.Token, golexgen.Continued) {
	return golexgen.NewToken(
		golexgen.TagIdent,
		start, end,
		string(text[start.Index():end.Index()]),
	), false
}

func (h *Handler) Num(
	text []rune,
	start, end golexgen.Position,
	errFunc golexgen.ErrFunc,
	switchCond golexgen.SwitchConditionFunc,
) (golexgen.Token, golexgen.Continued) {
	return golexgen.NewToken(
		golexgen.TagNum,
		start, end,
		string(text[start.Index():end.Index()]),
	), false
}

func main() {
	filePath := "./examples/lab1.2/test.txt"

	content, err := os.ReadFile(filePath)
	if err != nil {
		panic(err)
	}
	scn := golexgen.NewScanner([]rune(string(content)), &Handler{})

	t := scn.NextToken()
	for t.Tag() != golexgen.EOP {
		fmt.Println(t.String())
		t = scn.NextToken()
	}
}
