// Code generated by golex utility; DO NOT EDIT.
package golexgen

import (
	"fmt"
	"unicode"
)

type FiniteState struct {
	NextState      int
	CurrentState   int
	TerminalStates []int
	Transitions    map[int]map[rune]int
}

func (f *FiniteState) FindMatchEndIndex(input string) int {
	f.CurrentState = 0
	i := 0
	for _, ch := range input {
		if !f.canMoveBy(ch) {
			break
		}
		i++
	}

	if f.isTerminal(f.CurrentState) {
		return i
	}

	return 0
}

func (f *FiniteState) canMoveBy(ch rune) bool {
	from := f.CurrentState
	if to, ok := f.Transitions[from][ch]; ok {
		f.CurrentState = to
		return true
	}

	return false
}

func (f *FiniteState) isTerminal(state int) bool {
	for _, val := range f.TerminalStates {
		if state == val {
			return true
		}
	}
	return false
}

var (
	automataSkip *FiniteState = &FiniteState{
		CurrentState:   0,
		TerminalStates: []int{10, 12, 11, 3, 6},
		Transitions: map[int]map[rune]int{
			0: {48: 3, 49: 3, 50: 3, 51: 3, 52: 3, 53: 3, 54: 3, 55: 3, 56: 3, 57: 3, 65: 1, 66: 1, 67: 1, 68: 1, 69: 1, 70: 1, 71: 1, 72: 1, 73: 1, 74: 1, 75: 1, 76: 1, 77: 1, 78: 1, 79: 1, 80: 1, 81: 1, 82: 1, 83: 1, 84: 1, 85: 1, 86: 1, 87: 1, 88: 1, 89: 1, 90: 1, 97: 2, 98: 2, 99: 2, 100: 2, 101: 2, 102: 2, 103: 2, 104: 2, 105: 2, 106: 2, 107: 2, 108: 2, 109: 2, 110: 2, 111: 2, 112: 2, 113: 2, 114: 2, 115: 2, 116: 2, 117: 2, 118: 2, 119: 2, 120: 2, 121: 2, 122: 2},
			1: {48: 6, 49: 6, 50: 6, 51: 6, 52: 6, 53: 6, 54: 6, 55: 6, 56: 6, 57: 6, 65: 4, 66: 4, 67: 4, 68: 4, 69: 4, 70: 4, 71: 4, 72: 4, 73: 4, 74: 4, 75: 4, 76: 4, 77: 4, 78: 4, 79: 4, 80: 4, 81: 4, 82: 4, 83: 4, 84: 4, 85: 4, 86: 4, 87: 4, 88: 4, 89: 4, 90: 4, 97: 5, 98: 5, 99: 5, 100: 5, 101: 5, 102: 5, 103: 5, 104: 5, 105: 5, 106: 5, 107: 5, 108: 5, 109: 5, 110: 5, 111: 5, 112: 5, 113: 5, 114: 5, 115: 5, 116: 5, 117: 5, 118: 5, 119: 5, 120: 5, 121: 5, 122: 5, 123: 7},
			2: {48: 6, 49: 6, 50: 6, 51: 6, 52: 6, 53: 6, 54: 6, 55: 6, 56: 6, 57: 6, 65: 4, 66: 4, 67: 4, 68: 4, 69: 4, 70: 4, 71: 4, 72: 4, 73: 4, 74: 4, 75: 4, 76: 4, 77: 4, 78: 4, 79: 4, 80: 4, 81: 4, 82: 4, 83: 4, 84: 4, 85: 4, 86: 4, 87: 4, 88: 4, 89: 4, 90: 4, 97: 5, 98: 5, 99: 5, 100: 5, 101: 5, 102: 5, 103: 5, 104: 5, 105: 5, 106: 5, 107: 5, 108: 5, 109: 5, 110: 5, 111: 5, 112: 5, 113: 5, 114: 5, 115: 5, 116: 5, 117: 5, 118: 5, 119: 5, 120: 5, 121: 5, 122: 5, 123: 7},
			3: {48: 6, 49: 6, 50: 6, 51: 6, 52: 6, 53: 6, 54: 6, 55: 6, 56: 6, 57: 6, 65: 4, 66: 4, 67: 4, 68: 4, 69: 4, 70: 4, 71: 4, 72: 4, 73: 4, 74: 4, 75: 4, 76: 4, 77: 4, 78: 4, 79: 4, 80: 4, 81: 4, 82: 4, 83: 4, 84: 4, 85: 4, 86: 4, 87: 4, 88: 4, 89: 4, 90: 4, 97: 5, 98: 5, 99: 5, 100: 5, 101: 5, 102: 5, 103: 5, 104: 5, 105: 5, 106: 5, 107: 5, 108: 5, 109: 5, 110: 5, 111: 5, 112: 5, 113: 5, 114: 5, 115: 5, 116: 5, 117: 5, 118: 5, 119: 5, 120: 5, 121: 5, 122: 5, 123: 7},
			4: {48: 6, 49: 6, 50: 6, 51: 6, 52: 6, 53: 6, 54: 6, 55: 6, 56: 6, 57: 6, 65: 4, 66: 4, 67: 4, 68: 4, 69: 4, 70: 4, 71: 4, 72: 4, 73: 4, 74: 4, 75: 4, 76: 4, 77: 4, 78: 4, 79: 4, 80: 4, 81: 4, 82: 4, 83: 4, 84: 4, 85: 4, 86: 4, 87: 4, 88: 4, 89: 4, 90: 4, 97: 5, 98: 5, 99: 5, 100: 5, 101: 5, 102: 5, 103: 5, 104: 5, 105: 5, 106: 5, 107: 5, 108: 5, 109: 5, 110: 5, 111: 5, 112: 5, 113: 5, 114: 5, 115: 5, 116: 5, 117: 5, 118: 5, 119: 5, 120: 5, 121: 5, 122: 5, 123: 7},
			5: {48: 6, 49: 6, 50: 6, 51: 6, 52: 6, 53: 6, 54: 6, 55: 6, 56: 6, 57: 6, 65: 4, 66: 4, 67: 4, 68: 4, 69: 4, 70: 4, 71: 4, 72: 4, 73: 4, 74: 4, 75: 4, 76: 4, 77: 4, 78: 4, 79: 4, 80: 4, 81: 4, 82: 4, 83: 4, 84: 4, 85: 4, 86: 4, 87: 4, 88: 4, 89: 4, 90: 4, 97: 5, 98: 5, 99: 5, 100: 5, 101: 5, 102: 5, 103: 5, 104: 5, 105: 5, 106: 5, 107: 5, 108: 5, 109: 5, 110: 5, 111: 5, 112: 5, 113: 5, 114: 5, 115: 5, 116: 5, 117: 5, 118: 5, 119: 5, 120: 5, 121: 5, 122: 5, 123: 7},
			6: {48: 6, 49: 6, 50: 6, 51: 6, 52: 6, 53: 6, 54: 6, 55: 6, 56: 6, 57: 6, 65: 4, 66: 4, 67: 4, 68: 4, 69: 4, 70: 4, 71: 4, 72: 4, 73: 4, 74: 4, 75: 4, 76: 4, 77: 4, 78: 4, 79: 4, 80: 4, 81: 4, 82: 4, 83: 4, 84: 4, 85: 4, 86: 4, 87: 4, 88: 4, 89: 4, 90: 4, 97: 5, 98: 5, 99: 5, 100: 5, 101: 5, 102: 5, 103: 5, 104: 5, 105: 5, 106: 5, 107: 5, 108: 5, 109: 5, 110: 5, 111: 5, 112: 5, 113: 5, 114: 5, 115: 5, 116: 5, 117: 5, 118: 5, 119: 5, 120: 5, 121: 5, 122: 5, 123: 7},
			7: {48: 8, 49: 8, 50: 8, 51: 8, 52: 8, 53: 8, 54: 8, 55: 8, 56: 8, 57: 8},
			8: {48: 9, 49: 9, 50: 9, 51: 9, 52: 9, 53: 9, 54: 9, 55: 9, 56: 9, 57: 9, 125: 10},
			9: {48: 9, 49: 9, 50: 9, 51: 9, 52: 9, 53: 9, 54: 9, 55: 9, 56: 9, 57: 9, 125: 10},
		},
	}
)

type ErrHandler interface {
	Error(msg string, pos Position, symbol string)
}

type ErrHandlerBase struct{}

func (e *ErrHandlerBase) Error(msg string, pos Position, symbol string) {
	fmt.Printf("%s %s %s\n", msg, pos.String(), symbol)
}

type LexemHandler interface {
	ErrHandler
	Skip(text []rune, start, end Position) *Token
}

type Tag interface {
	GetTag() string
}

const EOP = "EOP"

type EOPTag struct{}

func (e EOPTag) GetTag() string {
	return EOP
}

type Token struct {
	tag    Tag
	coords Fragment
	val    string
}

func NewToken(tag Tag, starting, following Position, val string) Token {
	return Token{tag: tag, coords: NewFragment(starting, following), val: val}
}

func (t Token) String() string {
	return fmt.Sprintf("%s %s: %s", t.tag.GetTag(), t.coords, t.val)
}

func (t Token) Tag() string {
	return t.tag.GetTag()
}

type Fragment struct {
	starting  Position
	following Position
}

func NewFragment(starting, following Position) Fragment {
	return Fragment{starting: starting, following: following}
}

func (f Fragment) String() string {
	return fmt.Sprintf("%s-%s", f.starting.String(), f.following.String())
}

type Position struct {
	line  int
	pos   int
	index int
	text  []rune
}

func NewPosition(text []rune) Position {
	return Position{text: text, line: 1, pos: 1}
}

func (p *Position) String() string {
	return fmt.Sprintf("(%d,%d)", p.line, p.pos)
}

func (p *Position) cp() int {
	if p.index == len(p.text) {
		return -1
	}
	return int(p.text[p.index])
}

func (p *Position) isWhiteSpace() bool {
	return p.cp() == ' '
}

func (p *Position) isLetter() bool {
	return unicode.IsLetter(rune(p.cp()))
}

func (p *Position) isNewLine() bool {
	return p.cp() == '\n'
}

func (p *Position) Index() int {
	return p.index
}

func (p *Position) next() Position {
	if p.index < len(p.text) {
		if p.isNewLine() {
			p.line++
			p.pos = 1
		} else {
			p.pos++
		}
		p.index++
	}

	return *p
}

type Scanner struct {
	program []rune
	handler LexemHandler
	regexps []*FiniteState
	curPos  Position
}

func NewScanner(program []rune, handler LexemHandler) Scanner {
	regexps := make([]*FiniteState, 0, 1)
	regexps = append(regexps, automataSkip)

	return Scanner{program: program, handler: handler, regexps: regexps, curPos: NewPosition(program)}
}

func (s *Scanner) findToken(automata *FiniteState, start, end Position) *Token {
	switch automata {
	case automataSkip:
		return s.handler.Skip(s.program, start, end)

	}
	return nil
}

func (s *Scanner) NextToken() Token {
	for s.curPos.cp() != -1 {
		start := s.curPos.index

		var maxRightReg *FiniteState
		maxRight := 0

		for _, r := range s.regexps {
			res := r.FindMatchEndIndex(string(s.program[s.curPos.index:]))
			if res > maxRight {
				maxRightReg = r
				maxRight = res
			}
		}
		startPos := s.curPos
		var pos Position
		for s.curPos.index != start+maxRight {
			pos = s.curPos
			s.curPos.next()
		}
		pos.index++

		if maxRight == 0 {
			if s.curPos.cp() != -1 {
				s.curPos.next()
			} else {
				break
			}
			s.handler.Error("unknown symbol", startPos, string(s.program[start]))
		} else {
			tok := s.findToken(maxRightReg, startPos, pos)
			if tok != nil {
				return *tok
			}
		}
	}

	return NewToken(EOPTag{}, s.curPos, s.curPos, "")
}
