// Code generated by golex utility; DO NOT EDIT.
package golexgen

import (
	"bufio"
	"fmt"
)

type ErrHandler interface {
	Error(msg string, pos Position, symbol string)
}

type (
	ErrFunc             func(msg string, pos Position, symbol string)
	SwitchConditionFunc func(cond Condition)
)

type Continued bool

type LexemHandler interface {
	ErrHandler
	Skip(text string, start, end Position, errFunc ErrFunc, switchCond SwitchConditionFunc) (Token, Continued)
	RegularStart(text string, start, end Position, errFunc ErrFunc, switchCond SwitchConditionFunc) (Token, Continued)
	RegularEnd(text string, start, end Position, errFunc ErrFunc, switchCond SwitchConditionFunc) (Token, Continued)
	RegularNewLine(text string, start, end Position, errFunc ErrFunc, switchCond SwitchConditionFunc) (Token, Continued)
	RegularEscapeNewLine(text string, start, end Position, errFunc ErrFunc, switchCond SwitchConditionFunc) (Token, Continued)
	RegularEscapeTab(text string, start, end Position, errFunc ErrFunc, switchCond SwitchConditionFunc) (Token, Continued)
	RegularEscapeQota(text string, start, end Position, errFunc ErrFunc, switchCond SwitchConditionFunc) (Token, Continued)
	RegularSymb(text string, start, end Position, errFunc ErrFunc, switchCond SwitchConditionFunc) (Token, Continued)
	StartLiteral(text string, start, end Position, errFunc ErrFunc, switchCond SwitchConditionFunc) (Token, Continued)
	Literal1(text string, start, end Position, errFunc ErrFunc, switchCond SwitchConditionFunc) (Token, Continued)
	LiteralEnd(text string, start, end Position, errFunc ErrFunc, switchCond SwitchConditionFunc) (Token, Continued)
	LiteralNewLine(text string, start, end Position, errFunc ErrFunc, switchCond SwitchConditionFunc) (Token, Continued)
	LiteralChar(text string, start, end Position, errFunc ErrFunc, switchCond SwitchConditionFunc) (Token, Continued)
	Num(text string, start, end Position, errFunc ErrFunc, switchCond SwitchConditionFunc) (Token, Continued)
	Any(text string, start, end Position, errFunc ErrFunc, switchCond SwitchConditionFunc) (Token, Continued)
}

type Tag interface {
	GetTag() string
}

const EOP = "EOP"

type Condition int

const (
	dummy = Condition(iota)

	ConditionINIT
	ConditionLITERAL
	ConditionREGULAR
)

type DefaultTag int

const (
	TagErr DefaultTag = iota
	TagSkip
	TagRegularStart
	TagRegularEnd
	TagRegularNewLine
	TagRegularEscapeNewLine
	TagRegularEscapeTab
	TagRegularEscapeQota
	TagRegularSymb
	TagStartLiteral
	TagLiteral1
	TagLiteralEnd
	TagLiteralNewLine
	TagLiteralChar
	TagNum
	TagAny
	TagINIT
	TagLITERAL
	TagREGULAR
)

func (t DefaultTag) GetTag() string {
	var tagToString = map[DefaultTag]string{
		TagSkip:                 "Skip",
		TagRegularStart:         "RegularStart",
		TagRegularEnd:           "RegularEnd",
		TagRegularNewLine:       "RegularNewLine",
		TagRegularEscapeNewLine: "RegularEscapeNewLine",
		TagRegularEscapeTab:     "RegularEscapeTab",
		TagRegularEscapeQota:    "RegularEscapeQota",
		TagRegularSymb:          "RegularSymb",
		TagStartLiteral:         "StartLiteral",
		TagLiteral1:             "Literal1",
		TagLiteralEnd:           "LiteralEnd",
		TagLiteralNewLine:       "LiteralNewLine",
		TagLiteralChar:          "LiteralChar",
		TagNum:                  "Num",
		TagAny:                  "Any",
		TagINIT:                 "INIT",
		TagLITERAL:              "LITERAL",
		TagREGULAR:              "REGULAR",
	}

	return tagToString[t]
}

type FiniteState struct {
	NextState      int
	CurrentState   int
	TerminalStates []TerminalState
	Transitions    map[int]map[rune]int
}

type TerminalState struct {
	state     int
	lexemName string
}

func (f *FiniteState) FindLexemOneAutomata(pos Position) (string, string, Position) {
	f.CurrentState = 0
	prevWord := ""
	prevStr := ""
	curWord := ""
	var prevResPos Position
	for pos.cp() != -1 {
		ch := rune(pos.cp())
		if !f.canMoveBy(ch) {
			break
		}
		curWord += string(ch)

		if val, ok := f.isTerminalOneAutomata(f.CurrentState); ok {
			prevResPos = pos
			prevWord = curWord
			prevStr = val.lexemName
		}

		pos.next()
	}

	return prevWord, prevStr, prevResPos
}

func (f *FiniteState) canMoveBy(ch rune) bool {
	from := f.CurrentState
	if to, ok := f.Transitions[from][ch]; ok {
		f.CurrentState = to
		return true
	}

	return false
}

func (f *FiniteState) isTerminalOneAutomata(state int) (TerminalState, bool) {
	for _, val := range f.TerminalStates {
		if state == val.state {
			return val, true
		}
	}
	return TerminalState{}, false
}

func (f *FiniteState) isTerminal(state int) bool {
	for _, val := range f.TerminalStates {
		if state == val.state {
			return true
		}
	}
	return false
}

var (
	unionAutomataINIT *FiniteState = &FiniteState{
		CurrentState:   0,
		TerminalStates: []TerminalState{{state: 0, lexemName: "Any"}, {state: 1, lexemName: "Any"}, {state: 2, lexemName: "Skip"}, {state: 3, lexemName: "Skip"}, {state: 4, lexemName: "Num"}, {state: 5, lexemName: "Num"}, {state: 6, lexemName: "RegularStart"}, {state: 7, lexemName: "Any"}, {state: 8, lexemName: "Num"}, {state: 9, lexemName: "StartLiteral"}},
		Transitions: map[int]map[rune]int{
			0: {9: 2, 10: 3, 32: 2, 33: 1, 34: 6, 35: 1, 36: 1, 37: 1, 38: 1, 39: 1, 40: 1, 41: 1, 42: 1, 43: 1, 44: 1, 45: 1, 46: 1, 47: 1, 48: 4, 49: 5, 50: 1, 51: 1, 52: 1, 53: 1, 54: 1, 55: 1, 56: 1, 57: 1, 58: 1, 59: 1, 60: 1, 61: 1, 62: 1, 63: 1, 64: 7, 65: 1, 66: 1, 67: 1, 68: 1, 69: 1, 70: 1, 71: 1, 72: 1, 73: 1, 74: 1, 75: 1, 76: 1, 77: 1, 78: 1, 79: 1, 80: 1, 81: 1, 82: 1, 83: 1, 84: 1, 85: 1, 86: 1, 87: 1, 88: 1, 89: 1, 90: 1, 91: 1, 92: 1, 93: 1, 94: 1, 95: 1, 96: 1, 97: 1, 98: 1, 99: 1, 100: 1, 101: 1, 102: 1, 103: 1, 104: 1, 105: 1, 106: 1, 107: 1, 108: 1, 109: 1, 110: 1, 111: 1, 112: 1, 113: 1, 114: 1, 115: 1, 116: 1, 117: 1, 118: 1, 119: 1, 120: 1, 121: 1, 122: 1, 123: 1, 124: 1, 125: 1, 126: 1},
			2: {9: 3, 10: 3, 32: 3},
			3: {9: 3, 10: 3, 32: 3},
			5: {49: 8},
			7: {34: 9},
			8: {49: 8},
		},
	}
	unionAutomataREGULAR *FiniteState = &FiniteState{
		CurrentState:   0,
		TerminalStates: []TerminalState{{state: 0, lexemName: "RegularSymb"}, {state: 1, lexemName: "RegularSymb"}, {state: 2, lexemName: "RegularEnd"}, {state: 3, lexemName: "RegularNewLine"}, {state: 4, lexemName: "RegularSymb"}, {state: 5, lexemName: "RegularEscapeTab"}, {state: 6, lexemName: "RegularEscapeQota"}, {state: 7, lexemName: "RegularEscapeNewLine"}},
		Transitions: map[int]map[rune]int{
			0: {9: 1, 10: 3, 32: 1, 33: 1, 34: 2, 35: 1, 36: 1, 37: 1, 38: 1, 39: 1, 40: 1, 41: 1, 42: 1, 43: 1, 44: 1, 45: 1, 46: 1, 47: 1, 48: 1, 49: 1, 50: 1, 51: 1, 52: 1, 53: 1, 54: 1, 55: 1, 56: 1, 57: 1, 58: 1, 59: 1, 60: 1, 61: 1, 62: 1, 63: 1, 64: 1, 65: 1, 66: 1, 67: 1, 68: 1, 69: 1, 70: 1, 71: 1, 72: 1, 73: 1, 74: 1, 75: 1, 76: 1, 77: 1, 78: 1, 79: 1, 80: 1, 81: 1, 82: 1, 83: 1, 84: 1, 85: 1, 86: 1, 87: 1, 88: 1, 89: 1, 90: 1, 91: 1, 92: 4, 93: 1, 94: 1, 95: 1, 96: 1, 97: 1, 98: 1, 99: 1, 100: 1, 101: 1, 102: 1, 103: 1, 104: 1, 105: 1, 106: 1, 107: 1, 108: 1, 109: 1, 110: 1, 111: 1, 112: 1, 113: 1, 114: 1, 115: 1, 116: 1, 117: 1, 118: 1, 119: 1, 120: 1, 121: 1, 122: 1, 123: 1, 124: 1, 125: 1, 126: 1},
			4: {34: 6, 110: 7, 116: 5},
		},
	}
	unionAutomataLITERAL *FiniteState = &FiniteState{
		CurrentState:   0,
		TerminalStates: []TerminalState{{state: 0, lexemName: "LiteralChar"}, {state: 1, lexemName: "LiteralChar"}, {state: 2, lexemName: "LiteralEnd"}, {state: 3, lexemName: "LiteralNewLine"}, {state: 4, lexemName: "Literal1"}},
		Transitions: map[int]map[rune]int{
			0: {9: 1, 10: 3, 32: 1, 33: 1, 34: 2, 35: 1, 36: 1, 37: 1, 38: 1, 39: 1, 40: 1, 41: 1, 42: 1, 43: 1, 44: 1, 45: 1, 46: 1, 47: 1, 48: 1, 49: 1, 50: 1, 51: 1, 52: 1, 53: 1, 54: 1, 55: 1, 56: 1, 57: 1, 58: 1, 59: 1, 60: 1, 61: 1, 62: 1, 63: 1, 64: 1, 65: 1, 66: 1, 67: 1, 68: 1, 69: 1, 70: 1, 71: 1, 72: 1, 73: 1, 74: 1, 75: 1, 76: 1, 77: 1, 78: 1, 79: 1, 80: 1, 81: 1, 82: 1, 83: 1, 84: 1, 85: 1, 86: 1, 87: 1, 88: 1, 89: 1, 90: 1, 91: 1, 92: 1, 93: 1, 94: 1, 95: 1, 96: 1, 97: 1, 98: 1, 99: 1, 100: 1, 101: 1, 102: 1, 103: 1, 104: 1, 105: 1, 106: 1, 107: 1, 108: 1, 109: 1, 110: 1, 111: 1, 112: 1, 113: 1, 114: 1, 115: 1, 116: 1, 117: 1, 118: 1, 119: 1, 120: 1, 121: 1, 122: 1, 123: 1, 124: 1, 125: 1, 126: 1},
			2: {34: 4},
		},
	}
)

type HandlerBase struct{}

func (e *HandlerBase) Error(msg string, pos Position, symbol string) {
	fmt.Printf("ERROR%s: %s %s\n", pos.String(), msg, symbol)
}

func (h *HandlerBase) Skip(
	text string,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	return Token{}, true
}

func (h *HandlerBase) RegularStart(
	text string,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	switchCond(ConditionREGULAR)

	return NewToken(TagRegularStart, start, end, text), false
}

func (h *HandlerBase) RegularEnd(
	text string,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	switchCond(ConditionINIT)

	return NewToken(TagRegularEnd, start, end, text), false
}

func (h *HandlerBase) RegularNewLine(
	text string,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	switchCond(ConditionINIT)

	return NewToken(TagRegularNewLine, start, end, text), false
}

func (h *HandlerBase) RegularEscapeNewLine(
	text string,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	return NewToken(TagRegularEscapeNewLine, start, end, text), false
}

func (h *HandlerBase) RegularEscapeTab(
	text string,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	return NewToken(TagRegularEscapeTab, start, end, text), false
}

func (h *HandlerBase) RegularEscapeQota(
	text string,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	return NewToken(TagRegularEscapeQota, start, end, text), false
}

func (h *HandlerBase) RegularSymb(
	text string,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	return NewToken(TagRegularSymb, start, end, text), false
}

func (h *HandlerBase) StartLiteral(
	text string,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	switchCond(ConditionLITERAL)

	return NewToken(TagStartLiteral, start, end, text), false
}

func (h *HandlerBase) Literal1(
	text string,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	return NewToken(TagLiteral1, start, end, text), false
}

func (h *HandlerBase) LiteralEnd(
	text string,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	switchCond(ConditionINIT)

	return NewToken(TagLiteralEnd, start, end, text), false
}

func (h *HandlerBase) LiteralNewLine(
	text string,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	return NewToken(TagLiteralNewLine, start, end, text), false
}

func (h *HandlerBase) LiteralChar(
	text string,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	return NewToken(TagLiteralChar, start, end, text), false
}

func (h *HandlerBase) Num(
	text string,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	return NewToken(TagNum, start, end, text), false
}

func (h *HandlerBase) Any(
	text string,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	return NewToken(TagAny, start, end, text), false
}

type EOPTag struct{}

func (e EOPTag) GetTag() string {
	return EOP
}

type Token struct {
	tag    Tag
	coords fragment
	val    string
}

func NewToken(tag Tag, starting, following Position, val string) Token {
	return Token{tag: tag, coords: newFragment(starting, following), val: val}
}

func (t Token) String() string {
	return fmt.Sprintf("%s %s: %s", t.tag.GetTag(), t.coords, t.val)
}

func (t Token) Tag() string {
	return t.tag.GetTag()
}

type fragment struct {
	starting  Position
	following Position
}

func newFragment(starting, following Position) fragment {
	return fragment{starting: starting, following: following}
}

func (f fragment) String() string {
	return fmt.Sprintf("%s-%s", f.starting.String(), f.following.String())
}

type position struct {
	symb rune
	line int
	pos  int
}

func newPosition(symb rune) position {
	return position{symb: symb, line: 1, pos: 1}
}

type Position struct {
	position
	reader bufio.Reader
}

func NewPosition(reader bufio.Reader) Position {
	r, _, err := reader.ReadRune()
	if err != nil {
		r = -1
	}
	return Position{position: newPosition(r), reader: reader}
}

func (p *Position) String() string {
	return fmt.Sprintf("(%d,%d)", p.line, p.pos)
}

func (p *Position) cp() int {
	return int(p.symb)
}

func (p *Position) isNewLine() bool {
	return p.cp() == '\n'
}

func (p *Position) next() Position {
	r, _, err := p.reader.ReadRune()
	if err == nil {
		if p.isNewLine() {
			p.line++
			p.pos = 1
		} else {
			p.pos++
		}
		p.symb = r
	} else {
		p.symb = -1
	}

	return *p
}

type Scanner struct {
	programReader bufio.Reader
	handler       LexemHandler
	unionRegexps  map[Condition]*FiniteState
	curPos        Position

	curCondition Condition
}

func NewScanner(programFile bufio.Reader, handler LexemHandler) Scanner {
	unionRegexps := make(map[Condition]*FiniteState)

	unionRegexps[ConditionINIT] = unionAutomataINIT

	unionRegexps[ConditionLITERAL] = unionAutomataLITERAL

	unionRegexps[ConditionREGULAR] = unionAutomataREGULAR

	return Scanner{
		programReader: programFile,
		handler:       handler,
		unionRegexps:  unionRegexps,
		curPos:        NewPosition(programFile),
		curCondition:  ConditionINIT,
	}
}

func (s *Scanner) switchCondition(cond Condition) {
	s.curCondition = cond
}

func (s *Scanner) findTokenOneAutomata(
	curWord string,
	name string,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	switch s.curCondition {
	case ConditionINIT:
		return s.findTokenOneAutomataINIT(curWord, name, start, end, errFunc, switchCond)
	case ConditionLITERAL:
		return s.findTokenOneAutomataLITERAL(curWord, name, start, end, errFunc, switchCond)
	case ConditionREGULAR:
		return s.findTokenOneAutomataREGULAR(curWord, name, start, end, errFunc, switchCond)
	}

	return Token{}, true
}

func (s *Scanner) findTokenOneAutomataINIT(
	curWord string,
	name string,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	switch name {
	case "Skip":
		return s.handler.Skip(curWord, start, end, errFunc, switchCond)
	case "RegularStart":
		return s.handler.RegularStart(curWord, start, end, errFunc, switchCond)
	case "StartLiteral":
		return s.handler.StartLiteral(curWord, start, end, errFunc, switchCond)
	case "Num":
		return s.handler.Num(curWord, start, end, errFunc, switchCond)
	case "Any":
		return s.handler.Any(curWord, start, end, errFunc, switchCond)
	}

	return Token{}, true
}

func (s *Scanner) findTokenOneAutomataLITERAL(
	curWord string,
	name string,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	switch name {
	case "Literal1":
		return s.handler.Literal1(curWord, start, end, errFunc, switchCond)
	case "LiteralEnd":
		return s.handler.LiteralEnd(curWord, start, end, errFunc, switchCond)
	case "LiteralNewLine":
		return s.handler.LiteralNewLine(curWord, start, end, errFunc, switchCond)
	case "LiteralChar":
		return s.handler.LiteralChar(curWord, start, end, errFunc, switchCond)
	}

	return Token{}, true
}

func (s *Scanner) findTokenOneAutomataREGULAR(
	curWord string,
	name string,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	switch name {
	case "RegularEnd":
		return s.handler.RegularEnd(curWord, start, end, errFunc, switchCond)
	case "RegularNewLine":
		return s.handler.RegularNewLine(curWord, start, end, errFunc, switchCond)
	case "RegularEscapeNewLine":
		return s.handler.RegularEscapeNewLine(curWord, start, end, errFunc, switchCond)
	case "RegularEscapeTab":
		return s.handler.RegularEscapeTab(curWord, start, end, errFunc, switchCond)
	case "RegularEscapeQota":
		return s.handler.RegularEscapeQota(curWord, start, end, errFunc, switchCond)
	case "RegularSymb":
		return s.handler.RegularSymb(curWord, start, end, errFunc, switchCond)
	}

	return Token{}, true
}

func (s *Scanner) NextTokenOneAutomata() Token {
	for s.curPos.cp() != -1 {
		startPos := s.curPos
		res, name, pos := s.unionRegexps[s.curCondition].FindLexemOneAutomata(s.curPos)
		s.curPos = pos
		s.curPos.next()

		if len(name) == 0 {
			if s.curPos.cp() != -1 {
				s.curPos.next()
			} else {
				break
			}
			s.handler.Error("ERROR: unknown symbol", startPos, string(s.curPos.cp()))
		} else {
			tok, continued := s.findTokenOneAutomata(res, name, startPos, pos, s.handler.Error, s.switchCondition)
			if !continued {
				return tok
			}
		}
	}

	return NewToken(EOPTag{}, s.curPos, s.curPos, "")
}
