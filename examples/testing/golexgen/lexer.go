// Code generated by golex utility; DO NOT EDIT.
package golexgen

import (
	"fmt"
)

type ErrHandler interface {
	Error(msg string, pos Position, symbol string)
}

type (
	ErrFunc             func(msg string, pos Position, symbol string)
	SwitchConditionFunc func(cond Condition)
)

type Continued bool

type LexemHandler interface {
	ErrHandler
	A1(text string, start, end Position, errFunc ErrFunc, switchCond SwitchConditionFunc) (Token, Continued)
	A2(text string, start, end Position, errFunc ErrFunc, switchCond SwitchConditionFunc) (Token, Continued)
	A3(text string, start, end Position, errFunc ErrFunc, switchCond SwitchConditionFunc) (Token, Continued)
}

type Tag interface {
	GetTag() string
}

const EOP = "EOP"

type Condition int

const (
	dummy = Condition(iota)

	ConditionINIT
)

type DefaultTag int

const (
	TagErr DefaultTag = iota
	TagA1
	TagA2
	TagA3
	TagINIT
)

func (t DefaultTag) GetTag() string {
	var tagToString = map[DefaultTag]string{
		TagA1:   "A1",
		TagA2:   "A2",
		TagA3:   "A3",
		TagINIT: "INIT",
	}

	return tagToString[t]
}

type FiniteState struct {
	NextState      int
	CurrentState   int
	TerminalStates []TerminalState
	Transitions    map[int]map[rune]int
}

type TerminalState struct {
	state     int
	lexemName string
}

func (f *FiniteState) FindMatchEndIndex(input string) int {
	f.CurrentState = 0
	i := 0
	for _, ch := range input {
		if !f.canMoveBy(ch) {
			break
		}
		i++
	}

	if f.isTerminal(f.CurrentState) {
		return i
	}

	return 0
}

func (f *FiniteState) FindMatchEndIndexOneAutomata(input string) (int, string) {
	f.CurrentState = 0
	i := 0
	prevI := i
	prevStr := ""
	for _, ch := range input {
		if !f.canMoveBy(ch) {
			break
		}
		i++

		if val, ok := f.isTerminalOneAutoamta(f.CurrentState); ok {
			prevI = i
			prevStr = val.lexemName
		}
	}

	return prevI, prevStr
}

func (f *FiniteState) canMoveBy(ch rune) bool {
	from := f.CurrentState
	if to, ok := f.Transitions[from][ch]; ok {
		f.CurrentState = to
		return true
	}

	return false
}

func (f *FiniteState) isTerminalOneAutoamta(state int) (TerminalState, bool) {
	for _, val := range f.TerminalStates {
		if state == val.state {
			return val, true
		}
	}
	return TerminalState{}, false
}

func (f *FiniteState) isTerminal(state int) bool {
	for _, val := range f.TerminalStates {
		if state == val.state {
			return true
		}
	}
	return false
}

var (
	automataA1 *FiniteState = &FiniteState{
		CurrentState:   0,
		TerminalStates: []TerminalState{{state: 1, lexemName: "A1"}},
		Transitions: map[int]map[rune]int{
			0: {97: 1},
		},
	}
	automataA2 *FiniteState = &FiniteState{
		CurrentState:   0,
		TerminalStates: []TerminalState{{state: 3, lexemName: "A2"}},
		Transitions: map[int]map[rune]int{
			0: {97: 1},
			1: {98: 2},
			2: {98: 3},
		},
	}
	automataA3 *FiniteState = &FiniteState{
		CurrentState:   0,
		TerminalStates: []TerminalState{{state: 3, lexemName: "A3"}, {state: 2, lexemName: "A3"}},
		Transitions: map[int]map[rune]int{
			0: {97: 1, 98: 2},
			1: {97: 1, 98: 2},
			2: {98: 3},
			3: {98: 3},
		},
	}

	automataUnionRegexps *FiniteState = &FiniteState{
		CurrentState:   0,
		TerminalStates: []TerminalState{{state: 0, lexemName: ""}, {state: 5, lexemName: "A2"}, {state: 2, lexemName: "A1"}, {state: 8, lexemName: "A3"}, {state: 7, lexemName: "A3"}, {state: 4, lexemName: ""}},
		Transitions: map[int]map[rune]int{
			0: {97: 2, 98: 7},
			2: {97: 2, 98: 4},
			4: {98: 5},
			5: {98: 5},
		},
	}
)

type HandlerBase struct{}

func (e *HandlerBase) Error(msg string, pos Position, symbol string) {
	fmt.Printf("ERROR%s: %s %s\n", pos.String(), msg, symbol)
}

func (h *HandlerBase) A1(
	text string,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	return NewToken(TagA1, start, end, text), false
}

func (h *HandlerBase) A2(
	text string,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	return NewToken(TagA2, start, end, text), false
}

func (h *HandlerBase) A3(
	text string,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	return NewToken(TagA3, start, end, text), false
}

type EOPTag struct{}

func (e EOPTag) GetTag() string {
	return EOP
}

type Token struct {
	tag    Tag
	coords fragment
	val    string
}

func NewToken(tag Tag, starting, following Position, val string) Token {
	return Token{tag: tag, coords: newFragment(starting, following), val: val}
}

func (t Token) String() string {
	return fmt.Sprintf("%s %s: %s", t.tag.GetTag(), t.coords, t.val)
}

func (t Token) Tag() string {
	return t.tag.GetTag()
}

type fragment struct {
	starting  Position
	following Position
}

func newFragment(starting, following Position) fragment {
	return fragment{starting: starting, following: following}
}

func (f fragment) String() string {
	return fmt.Sprintf("%s-%s", f.starting.String(), f.following.String())
}

type Position struct {
	line  int
	pos   int
	index int
	text  []rune
}

func NewPosition(text []rune) Position {
	return Position{text: text, line: 1, pos: 1}
}

func (p *Position) String() string {
	return fmt.Sprintf("(%d,%d)", p.line, p.pos)
}

func (p *Position) cp() int {
	if p.index == len(p.text) {
		return -1
	}
	return int(p.text[p.index])
}

func (p *Position) isNewLine() bool {
	return p.cp() == '\n'
}

func (p *Position) Index() int {
	return p.index
}

func (p *Position) next() Position {
	if p.index < len(p.text) {
		if p.isNewLine() {
			p.line++
			p.pos = 1
		} else {
			p.pos++
		}
		p.index++
	}

	return *p
}

type Scanner struct {
	program []rune
	handler LexemHandler
	regexps map[Condition][]*FiniteState
	curPos  Position

	curCondition Condition
}

func NewScanner(program []rune, handler LexemHandler) Scanner {
	regexps := make(map[Condition][]*FiniteState)

	regexps[ConditionINIT] = make([]*FiniteState, 0, 3)
	regexps[ConditionINIT] = append(regexps[ConditionINIT], automataA1)
	regexps[ConditionINIT] = append(regexps[ConditionINIT], automataA2)
	regexps[ConditionINIT] = append(regexps[ConditionINIT], automataA3)

	return Scanner{program: program, handler: handler, regexps: regexps, curPos: NewPosition(program), curCondition: ConditionINIT}
}

func (s *Scanner) switchCondition(cond Condition) {
	s.curCondition = cond
}

func (s *Scanner) findTokenOneAutomata(
	name string,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	switch s.curCondition {
	case ConditionINIT:
		return s.findTokenOneAutomataINIT(name, start, end, errFunc, switchCond)
	}

	return Token{}, true
}

func (s *Scanner) findTokenOneAutomataINIT(
	name string,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	switch name {
	case "A1":
		return s.handler.A1(string(s.program[start.Index():end.Index()]), start, end, errFunc, switchCond)
	case "A2":
		return s.handler.A2(string(s.program[start.Index():end.Index()]), start, end, errFunc, switchCond)
	case "A3":
		return s.handler.A3(string(s.program[start.Index():end.Index()]), start, end, errFunc, switchCond)
	}

	return Token{}, true
}

func (s *Scanner) findToken(
	automata *FiniteState,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	switch s.curCondition {
	case ConditionINIT:
		return s.findTokenINIT(automata, start, end, errFunc, switchCond)
	}

	return Token{}, true
}

func (s *Scanner) findTokenINIT(
	automata *FiniteState,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	switch automata {
	case automataA1:
		return s.handler.A1(string(s.program[start.Index():end.Index()]), start, end, errFunc, switchCond)
	case automataA2:
		return s.handler.A2(string(s.program[start.Index():end.Index()]), start, end, errFunc, switchCond)
	case automataA3:
		return s.handler.A3(string(s.program[start.Index():end.Index()]), start, end, errFunc, switchCond)
	}

	return Token{}, true
}

func (s *Scanner) NextTokenOneAutomata() Token {
	for s.curPos.cp() != -1 {
		start := s.curPos.index

		maxRight := 0
		res, name := automataUnionRegexps.FindMatchEndIndexOneAutomata(string(s.program[s.curPos.index:]))
		if res > 0 {
			maxRight = res
		}

		startPos := s.curPos
		var pos Position
		for s.curPos.index != start+maxRight {
			pos = s.curPos
			s.curPos.next()
		}
		pos.index++

		if maxRight == 0 {
			if s.curPos.cp() != -1 {
				s.curPos.next()
			} else {
				break
			}
			s.handler.Error("ERROR: unknown symbol", startPos, string(s.program[start]))
		} else {
			tok, continued := s.findTokenOneAutomata(name, startPos, pos, s.handler.Error, s.switchCondition)
			if !continued {
				return tok
			}
		}
	}

	return NewToken(EOPTag{}, s.curPos, s.curPos, "")
}

func (s *Scanner) NextToken() Token {
	for s.curPos.cp() != -1 {
		start := s.curPos.index

		var maxRightReg *FiniteState
		maxRight := 0

		for _, r := range s.regexps[s.curCondition] {
			res := r.FindMatchEndIndex(string(s.program[s.curPos.index:]))
			if res > maxRight {
				maxRightReg = r
				maxRight = res
			}
		}
		startPos := s.curPos
		var pos Position
		for s.curPos.index != start+maxRight {
			pos = s.curPos
			s.curPos.next()
		}
		pos.index++

		if maxRight == 0 {
			if s.curPos.cp() != -1 {
				s.curPos.next()
			} else {
				break
			}
			s.handler.Error("ERROR: unknown symbol", startPos, string(s.program[start]))
		} else {
			tok, continued := s.findToken(maxRightReg, startPos, pos, s.handler.Error, s.switchCondition)
			if !continued {
				return tok
			}
		}
	}

	return NewToken(EOPTag{}, s.curPos, s.curPos, "")
}
