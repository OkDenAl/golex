// Code generated by golex utility; DO NOT EDIT.
package golexgen

import (
	"fmt"
)

type ErrHandler interface {
	Error(msg string, pos Position, symbol string)
}

type (
	ErrFunc             func(msg string, pos Position, symbol string)
	SwitchConditionFunc func(cond Condition)
)

type Continued bool

type LexemHandler interface {
	ErrHandler
	Skip(text []rune, start, end Position, errFunc ErrFunc, switchCond SwitchConditionFunc) (Token, Continued)
	Assembly(text []rune, start, end Position, errFunc ErrFunc, switchCond SwitchConditionFunc) (Token, Continued)
	Ident(text []rune, start, end Position, errFunc ErrFunc, switchCond SwitchConditionFunc) (Token, Continued)
	Num(text []rune, start, end Position, errFunc ErrFunc, switchCond SwitchConditionFunc) (Token, Continued)
}

type Tag interface {
	GetTag() string
}

const EOP = "EOP"

type Condition int

const (
	dummy = Condition(iota)

	ConditionINIT
)

type DefaultTag int

const (
	TagErr DefaultTag = iota
	TagSkip
	TagAssembly
	TagIdent
	TagNum
	TagINIT
)

func (t DefaultTag) GetTag() string {
	var tagToString = map[DefaultTag]string{
		TagSkip:     "Skip",
		TagAssembly: "Assembly",
		TagIdent:    "Ident",
		TagNum:      "Num",
		TagINIT:     "INIT",
	}

	return tagToString[t]
}

type FiniteState struct {
	NextState      int
	CurrentState   int
	TerminalStates []TerminalState
	Transitions    map[int]map[rune]int
}

type TerminalState struct {
	state     int
	lexemName string
}

func (f *FiniteState) FindMatchEndIndex(input string) int {
	f.CurrentState = 0
	i := 0
	for _, ch := range input {
		if !f.canMoveBy(ch) {
			break
		}
		i++
	}

	if f.isTerminal(f.CurrentState) {
		return i
	}

	return 0
}

func (f *FiniteState) FindMatchEndIndexOneAutomata(input string) (int, string) {
	f.CurrentState = 0
	i := 0
	prevI := i
	prevStr := ""
	for _, ch := range input {
		if !f.canMoveBy(ch) {
			break
		}
		i++

		if val, ok := f.isTerminalOneAutoamta(f.CurrentState); ok {
			prevI = i
			prevStr = val.lexemName
		}
	}

	return prevI, prevStr
}

func (f *FiniteState) canMoveBy(ch rune) bool {
	from := f.CurrentState
	if to, ok := f.Transitions[from][ch]; ok {
		f.CurrentState = to
		return true
	}

	return false
}

func (f *FiniteState) isTerminalOneAutoamta(state int) (TerminalState, bool) {
	for _, val := range f.TerminalStates {
		if state == val.state {
			return val, true
		}
	}
	return TerminalState{}, false
}

func (f *FiniteState) isTerminal(state int) bool {
	for _, val := range f.TerminalStates {
		if state == val.state {
			return true
		}
	}
	return false
}

var (
	automataSkip *FiniteState = &FiniteState{
		CurrentState:   0,
		TerminalStates: []TerminalState{{state: 3, lexemName: "Skip"}, {state: 1, lexemName: "Skip"}, {state: 2, lexemName: "Skip"}, {state: 6, lexemName: "Skip"}, {state: 4, lexemName: "Skip"}, {state: 5, lexemName: "Skip"}},
		Transitions: map[int]map[rune]int{
			0: {9: 2, 10: 1, 32: 3},
			1: {9: 5, 10: 4, 32: 6},
			2: {9: 5, 10: 4, 32: 6},
			3: {9: 5, 10: 4, 32: 6},
			4: {9: 5, 10: 4, 32: 6},
			5: {9: 5, 10: 4, 32: 6},
			6: {9: 5, 10: 4, 32: 6},
		},
	}
	automataAssembly *FiniteState = &FiniteState{
		CurrentState:   0,
		TerminalStates: []TerminalState{{state: 3, lexemName: "Assembly"}, {state: 6, lexemName: "Assembly"}},
		Transitions: map[int]map[rune]int{
			0: {101: 4, 109: 1},
			1: {111: 2},
			2: {118: 3},
			4: {97: 5},
			5: {120: 6},
		},
	}
	automataIdent *FiniteState = &FiniteState{
		CurrentState:   0,
		TerminalStates: []TerminalState{{state: 1, lexemName: "Ident"}, {state: 2, lexemName: "Ident"}, {state: 3, lexemName: "Ident"}, {state: 4, lexemName: "Ident"}, {state: 5, lexemName: "Ident"}},
		Transitions: map[int]map[rune]int{
			0: {65: 1, 66: 1, 67: 1, 68: 1, 69: 1, 70: 1, 71: 1, 72: 1, 73: 1, 74: 1, 75: 1, 76: 1, 77: 1, 78: 1, 79: 1, 80: 1, 81: 1, 82: 1, 83: 1, 84: 1, 85: 1, 86: 1, 87: 1, 88: 1, 89: 1, 90: 1, 97: 2, 98: 2, 99: 2, 100: 2, 101: 2, 102: 2, 103: 2, 104: 2, 105: 2, 106: 2, 107: 2, 108: 2, 109: 2, 110: 2, 111: 2, 112: 2, 113: 2, 114: 2, 115: 2, 116: 2, 117: 2, 118: 2, 119: 2, 120: 2, 121: 2, 122: 2},
			1: {48: 5, 49: 5, 50: 5, 51: 5, 52: 5, 53: 5, 54: 5, 55: 5, 56: 5, 57: 5, 65: 3, 66: 3, 67: 3, 68: 3, 69: 3, 70: 3, 71: 3, 72: 3, 73: 3, 74: 3, 75: 3, 76: 3, 77: 3, 78: 3, 79: 3, 80: 3, 81: 3, 82: 3, 83: 3, 84: 3, 85: 3, 86: 3, 87: 3, 88: 3, 89: 3, 90: 3, 97: 4, 98: 4, 99: 4, 100: 4, 101: 4, 102: 4, 103: 4, 104: 4, 105: 4, 106: 4, 107: 4, 108: 4, 109: 4, 110: 4, 111: 4, 112: 4, 113: 4, 114: 4, 115: 4, 116: 4, 117: 4, 118: 4, 119: 4, 120: 4, 121: 4, 122: 4},
			2: {48: 5, 49: 5, 50: 5, 51: 5, 52: 5, 53: 5, 54: 5, 55: 5, 56: 5, 57: 5, 65: 3, 66: 3, 67: 3, 68: 3, 69: 3, 70: 3, 71: 3, 72: 3, 73: 3, 74: 3, 75: 3, 76: 3, 77: 3, 78: 3, 79: 3, 80: 3, 81: 3, 82: 3, 83: 3, 84: 3, 85: 3, 86: 3, 87: 3, 88: 3, 89: 3, 90: 3, 97: 4, 98: 4, 99: 4, 100: 4, 101: 4, 102: 4, 103: 4, 104: 4, 105: 4, 106: 4, 107: 4, 108: 4, 109: 4, 110: 4, 111: 4, 112: 4, 113: 4, 114: 4, 115: 4, 116: 4, 117: 4, 118: 4, 119: 4, 120: 4, 121: 4, 122: 4},
			3: {48: 5, 49: 5, 50: 5, 51: 5, 52: 5, 53: 5, 54: 5, 55: 5, 56: 5, 57: 5, 65: 3, 66: 3, 67: 3, 68: 3, 69: 3, 70: 3, 71: 3, 72: 3, 73: 3, 74: 3, 75: 3, 76: 3, 77: 3, 78: 3, 79: 3, 80: 3, 81: 3, 82: 3, 83: 3, 84: 3, 85: 3, 86: 3, 87: 3, 88: 3, 89: 3, 90: 3, 97: 4, 98: 4, 99: 4, 100: 4, 101: 4, 102: 4, 103: 4, 104: 4, 105: 4, 106: 4, 107: 4, 108: 4, 109: 4, 110: 4, 111: 4, 112: 4, 113: 4, 114: 4, 115: 4, 116: 4, 117: 4, 118: 4, 119: 4, 120: 4, 121: 4, 122: 4},
			4: {48: 5, 49: 5, 50: 5, 51: 5, 52: 5, 53: 5, 54: 5, 55: 5, 56: 5, 57: 5, 65: 3, 66: 3, 67: 3, 68: 3, 69: 3, 70: 3, 71: 3, 72: 3, 73: 3, 74: 3, 75: 3, 76: 3, 77: 3, 78: 3, 79: 3, 80: 3, 81: 3, 82: 3, 83: 3, 84: 3, 85: 3, 86: 3, 87: 3, 88: 3, 89: 3, 90: 3, 97: 4, 98: 4, 99: 4, 100: 4, 101: 4, 102: 4, 103: 4, 104: 4, 105: 4, 106: 4, 107: 4, 108: 4, 109: 4, 110: 4, 111: 4, 112: 4, 113: 4, 114: 4, 115: 4, 116: 4, 117: 4, 118: 4, 119: 4, 120: 4, 121: 4, 122: 4},
			5: {48: 5, 49: 5, 50: 5, 51: 5, 52: 5, 53: 5, 54: 5, 55: 5, 56: 5, 57: 5, 65: 3, 66: 3, 67: 3, 68: 3, 69: 3, 70: 3, 71: 3, 72: 3, 73: 3, 74: 3, 75: 3, 76: 3, 77: 3, 78: 3, 79: 3, 80: 3, 81: 3, 82: 3, 83: 3, 84: 3, 85: 3, 86: 3, 87: 3, 88: 3, 89: 3, 90: 3, 97: 4, 98: 4, 99: 4, 100: 4, 101: 4, 102: 4, 103: 4, 104: 4, 105: 4, 106: 4, 107: 4, 108: 4, 109: 4, 110: 4, 111: 4, 112: 4, 113: 4, 114: 4, 115: 4, 116: 4, 117: 4, 118: 4, 119: 4, 120: 4, 121: 4, 122: 4},
		},
	}
	automataNum *FiniteState = &FiniteState{
		CurrentState:   0,
		TerminalStates: []TerminalState{{state: 1, lexemName: "Num"}, {state: 0, lexemName: "Num"}, {state: 6, lexemName: "Num"}},
		Transitions: map[int]map[rune]int{
			0: {48: 1, 49: 1, 50: 1, 51: 1, 52: 1, 53: 1, 54: 1, 55: 1, 56: 1, 57: 1},
			1: {48: 1, 49: 1, 50: 1, 51: 1, 52: 1, 53: 1, 54: 1, 55: 1, 56: 1, 57: 1, 65: 3, 66: 3, 67: 3, 68: 3, 69: 3, 70: 3, 97: 4, 98: 4, 99: 4, 100: 4, 101: 4, 102: 4, 104: 6},
			3: {48: 1, 49: 1, 50: 1, 51: 1, 52: 1, 53: 1, 54: 1, 55: 1, 56: 1, 57: 1, 65: 3, 66: 3, 67: 3, 68: 3, 69: 3, 70: 3, 97: 4, 98: 4, 99: 4, 100: 4, 101: 4, 102: 4, 104: 6},
			4: {48: 1, 49: 1, 50: 1, 51: 1, 52: 1, 53: 1, 54: 1, 55: 1, 56: 1, 57: 1, 65: 3, 66: 3, 67: 3, 68: 3, 69: 3, 70: 3, 97: 4, 98: 4, 99: 4, 100: 4, 101: 4, 102: 4, 104: 6},
		},
	}

	automataUnionRegexps *FiniteState = &FiniteState{
		CurrentState:   0,
		TerminalStates: []TerminalState{{state: 0, lexemName: ""}, {state: 6, lexemName: "Skip"}, {state: 13, lexemName: "Assembly"}, {state: 3, lexemName: "Skip"}, {state: 9, lexemName: ""}, {state: 19, lexemName: "Num"}, {state: 18, lexemName: "Ident"}, {state: 5, lexemName: "Skip"}, {state: 10, lexemName: "Assembly"}, {state: 16, lexemName: "Ident"}, {state: 17, lexemName: "Ident"}, {state: 11, lexemName: ""}, {state: 24, lexemName: "Num"}, {state: 7, lexemName: "Skip"}, {state: 14, lexemName: "Ident"}, {state: 4, lexemName: "Skip"}, {state: 2, lexemName: "Skip"}, {state: 15, lexemName: "Ident"}, {state: 8, lexemName: ""}, {state: 0, lexemName: "Num"}},
		Transitions: map[int]map[rune]int{
			0:  {9: 3, 10: 2, 32: 4, 48: 19, 49: 19, 50: 19, 51: 19, 52: 19, 53: 19, 54: 19, 55: 19, 56: 19, 57: 19, 65: 14, 66: 14, 67: 14, 68: 14, 69: 14, 70: 14, 71: 14, 72: 14, 73: 14, 74: 14, 75: 14, 76: 14, 77: 14, 78: 14, 79: 14, 80: 14, 81: 14, 82: 14, 83: 14, 84: 14, 85: 14, 86: 14, 87: 14, 88: 14, 89: 14, 90: 14, 97: 8, 98: 8, 99: 8, 100: 8, 101: 11, 102: 8, 103: 15, 104: 15, 105: 8, 106: 8, 107: 8, 108: 8, 109: 8, 110: 8, 111: 8, 112: 15, 113: 8, 114: 8, 115: 15, 116: 15, 117: 15, 118: 15, 119: 15, 120: 8, 121: 15, 122: 8},
			2:  {9: 6, 10: 5, 32: 7},
			3:  {9: 6, 10: 5, 32: 7},
			4:  {9: 6, 10: 5, 32: 7},
			5:  {9: 6, 10: 5, 32: 7},
			6:  {9: 6, 10: 5, 32: 7},
			7:  {9: 6, 10: 5, 32: 7},
			8:  {48: 18, 49: 18, 50: 18, 51: 18, 52: 18, 53: 18, 54: 18, 55: 18, 56: 18, 57: 18, 65: 16, 66: 16, 67: 16, 68: 16, 69: 16, 70: 16, 71: 16, 72: 16, 73: 16, 74: 16, 75: 16, 76: 16, 77: 16, 78: 16, 79: 16, 80: 16, 81: 16, 82: 16, 83: 16, 84: 16, 85: 16, 86: 16, 87: 16, 88: 16, 89: 16, 90: 16, 97: 9, 98: 9, 99: 17, 100: 9, 101: 17, 102: 9, 103: 9, 104: 9, 105: 9, 106: 9, 107: 17, 108: 9, 109: 17, 110: 17, 111: 9, 112: 9, 113: 17, 114: 9, 115: 9, 116: 17, 117: 17, 118: 9, 119: 9, 120: 9, 121: 17, 122: 9},
			9:  {48: 18, 49: 18, 50: 18, 51: 18, 52: 18, 53: 18, 54: 18, 55: 18, 56: 18, 57: 18, 65: 16, 66: 16, 67: 16, 68: 16, 69: 16, 70: 16, 71: 16, 72: 16, 73: 16, 74: 16, 75: 16, 76: 16, 77: 16, 78: 16, 79: 16, 80: 16, 81: 16, 82: 16, 83: 16, 84: 16, 85: 16, 86: 16, 87: 16, 88: 16, 89: 16, 90: 16, 97: 9, 98: 9, 99: 9, 100: 9, 101: 9, 102: 9, 103: 9, 104: 9, 105: 9, 106: 9, 107: 9, 108: 9, 109: 9, 110: 9, 111: 9, 112: 9, 113: 9, 114: 9, 115: 9, 116: 9, 117: 9, 118: 10, 119: 9, 120: 9, 121: 9, 122: 9},
			11: {97: 12},
			12: {120: 13},
			14: {48: 18, 49: 18, 50: 18, 51: 18, 52: 18, 53: 18, 54: 18, 55: 18, 56: 18, 57: 18, 65: 16, 66: 16, 67: 16, 68: 16, 69: 16, 70: 16, 71: 16, 72: 16, 73: 16, 74: 16, 75: 16, 76: 16, 77: 16, 78: 16, 79: 16, 80: 16, 81: 16, 82: 16, 83: 16, 84: 16, 85: 16, 86: 16, 87: 16, 88: 16, 89: 16, 90: 16, 97: 17, 98: 17, 99: 17, 100: 17, 101: 17, 102: 17, 103: 17, 104: 17, 105: 17, 106: 17, 107: 17, 108: 17, 109: 17, 110: 17, 111: 17, 112: 17, 113: 17, 114: 17, 115: 17, 116: 17, 117: 17, 118: 17, 119: 17, 120: 17, 121: 17, 122: 17},
			16: {48: 18, 49: 18, 50: 18, 51: 18, 52: 18, 53: 18, 54: 18, 55: 18, 56: 18, 57: 18, 65: 16, 66: 16, 67: 16, 68: 16, 69: 16, 70: 16, 71: 16, 72: 16, 73: 16, 74: 16, 75: 16, 76: 16, 77: 16, 78: 16, 79: 16, 80: 16, 81: 16, 82: 16, 83: 16, 84: 16, 85: 16, 86: 16, 87: 16, 88: 16, 89: 16, 90: 16, 97: 9, 98: 9, 99: 9, 100: 9, 101: 9, 102: 9, 103: 9, 104: 9, 105: 9, 106: 9, 107: 9, 108: 9, 109: 9, 110: 9, 111: 9, 112: 9, 113: 9, 114: 9, 115: 9, 116: 9, 117: 9, 118: 9, 119: 9, 120: 9, 121: 9, 122: 9},
			18: {48: 18, 49: 18, 50: 18, 51: 18, 52: 18, 53: 18, 54: 18, 55: 18, 56: 18, 57: 18, 65: 16, 66: 16, 67: 16, 68: 16, 69: 16, 70: 16, 71: 16, 72: 16, 73: 16, 74: 16, 75: 16, 76: 16, 77: 16, 78: 16, 79: 16, 80: 16, 81: 16, 82: 16, 83: 16, 84: 16, 85: 16, 86: 16, 87: 16, 88: 16, 89: 16, 90: 16, 97: 9, 98: 9, 99: 9, 100: 9, 101: 9, 102: 9, 103: 9, 104: 9, 105: 9, 106: 9, 107: 9, 108: 9, 109: 9, 110: 9, 111: 9, 112: 9, 113: 9, 114: 9, 115: 9, 116: 9, 117: 9, 118: 9, 119: 9, 120: 9, 121: 9, 122: 9},
			19: {48: 19, 49: 19, 50: 19, 51: 19, 52: 19, 53: 19, 54: 19, 55: 19, 56: 19, 57: 19, 65: 21, 66: 21, 67: 21, 68: 21, 69: 21, 70: 21, 97: 22, 98: 22, 99: 22, 100: 22, 101: 22, 102: 22, 104: 24},
			21: {48: 19, 49: 19, 50: 19, 51: 19, 52: 19, 53: 19, 54: 19, 55: 19, 56: 19, 57: 19, 65: 21, 66: 21, 67: 21, 68: 21, 69: 21, 70: 21, 97: 22, 98: 22, 99: 22, 100: 22, 101: 22, 102: 22, 104: 24},
			22: {48: 19, 49: 19, 50: 19, 51: 19, 52: 19, 53: 19, 54: 19, 55: 19, 56: 19, 57: 19, 65: 21, 66: 21, 67: 21, 68: 21, 69: 21, 70: 21, 97: 22, 98: 22, 99: 22, 100: 22, 101: 22, 102: 22, 104: 24},
		},
	}
)

type ErrHandlerBase struct{}

func (e *ErrHandlerBase) Error(msg string, pos Position, symbol string) {
	fmt.Printf("ERROR%s: %s %s\n", pos.String(), msg, symbol)
}

type EOPTag struct{}

func (e EOPTag) GetTag() string {
	return EOP
}

type Token struct {
	tag    Tag
	coords fragment
	val    string
}

func NewToken(tag Tag, starting, following Position, val string) Token {
	return Token{tag: tag, coords: newFragment(starting, following), val: val}
}

func (t Token) String() string {
	return fmt.Sprintf("%s %s: %s", t.tag.GetTag(), t.coords, t.val)
}

func (t Token) Tag() string {
	return t.tag.GetTag()
}

type fragment struct {
	starting  Position
	following Position
}

func newFragment(starting, following Position) fragment {
	return fragment{starting: starting, following: following}
}

func (f fragment) String() string {
	return fmt.Sprintf("%s-%s", f.starting.String(), f.following.String())
}

type Position struct {
	line  int
	pos   int
	index int
	text  []rune
}

func NewPosition(text []rune) Position {
	return Position{text: text, line: 1, pos: 1}
}

func (p *Position) String() string {
	return fmt.Sprintf("(%d,%d)", p.line, p.pos)
}

func (p *Position) cp() int {
	if p.index == len(p.text) {
		return -1
	}
	return int(p.text[p.index])
}

func (p *Position) isNewLine() bool {
	return p.cp() == '\n'
}

func (p *Position) Index() int {
	return p.index
}

func (p *Position) next() Position {
	if p.index < len(p.text) {
		if p.isNewLine() {
			p.line++
			p.pos = 1
		} else {
			p.pos++
		}
		p.index++
	}

	return *p
}

type Scanner struct {
	program []rune
	handler LexemHandler
	regexps map[Condition][]*FiniteState
	curPos  Position

	curCondition Condition
}

func NewScanner(program []rune, handler LexemHandler) Scanner {
	regexps := make(map[Condition][]*FiniteState)

	regexps[ConditionINIT] = make([]*FiniteState, 0, 4)
	regexps[ConditionINIT] = append(regexps[ConditionINIT], automataSkip)
	regexps[ConditionINIT] = append(regexps[ConditionINIT], automataAssembly)
	regexps[ConditionINIT] = append(regexps[ConditionINIT], automataIdent)
	regexps[ConditionINIT] = append(regexps[ConditionINIT], automataNum)

	return Scanner{program: program, handler: handler, regexps: regexps, curPos: NewPosition(program), curCondition: ConditionINIT}
}

func (s *Scanner) switchCondition(cond Condition) {
	s.curCondition = cond
}

func (s *Scanner) findTokenOneAutomata(
	name string,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	switch s.curCondition {
	case ConditionINIT:
		return s.findTokenOneAutomataINIT(name, start, end, errFunc, switchCond)
	}

	return Token{}, true
}

func (s *Scanner) findTokenOneAutomataINIT(
	name string,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	switch name {
	case "Skip":
		return s.handler.Skip(s.program, start, end, errFunc, switchCond)
	case "Assembly":
		return s.handler.Assembly(s.program, start, end, errFunc, switchCond)
	case "Ident":
		return s.handler.Ident(s.program, start, end, errFunc, switchCond)
	case "Num":
		return s.handler.Num(s.program, start, end, errFunc, switchCond)
	}

	return Token{}, true
}

func (s *Scanner) findToken(
	automata *FiniteState,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	switch s.curCondition {
	case ConditionINIT:
		return s.findTokenINIT(automata, start, end, errFunc, switchCond)
	}

	return Token{}, true
}

func (s *Scanner) findTokenINIT(
	automata *FiniteState,
	start, end Position,
	errFunc ErrFunc,
	switchCond SwitchConditionFunc,
) (Token, Continued) {
	switch automata {
	case automataSkip:
		return s.handler.Skip(s.program, start, end, errFunc, switchCond)
	case automataAssembly:
		return s.handler.Assembly(s.program, start, end, errFunc, switchCond)
	case automataIdent:
		return s.handler.Ident(s.program, start, end, errFunc, switchCond)
	case automataNum:
		return s.handler.Num(s.program, start, end, errFunc, switchCond)
	}

	return Token{}, true
}

func (s *Scanner) NextTokenOneAutomata() Token {
	for s.curPos.cp() != -1 {
		start := s.curPos.index

		maxRight := 0
		res, name := automataUnionRegexps.FindMatchEndIndexOneAutomata(string(s.program[s.curPos.index:]))
		if res > 0 {
			maxRight = res
		}

		startPos := s.curPos
		var pos Position
		for s.curPos.index != start+maxRight {
			pos = s.curPos
			s.curPos.next()
		}
		pos.index++

		if maxRight == 0 {
			if s.curPos.cp() != -1 {
				s.curPos.next()
			} else {
				break
			}
			s.handler.Error("ERROR: unknown symbol", startPos, string(s.program[start]))
		} else {
			tok, continued := s.findTokenOneAutomata(name, startPos, pos, s.handler.Error, s.switchCondition)
			if !continued {
				return tok
			}
		}
	}

	return NewToken(EOPTag{}, s.curPos, s.curPos, "")
}

func (s *Scanner) NextToken() Token {
	for s.curPos.cp() != -1 {
		start := s.curPos.index

		var maxRightReg *FiniteState
		maxRight := 0

		for _, r := range s.regexps[s.curCondition] {
			res := r.FindMatchEndIndex(string(s.program[s.curPos.index:]))
			if res > maxRight {
				maxRightReg = r
				maxRight = res
			}
		}
		startPos := s.curPos
		var pos Position
		for s.curPos.index != start+maxRight {
			pos = s.curPos
			s.curPos.next()
		}
		pos.index++

		if maxRight == 0 {
			if s.curPos.cp() != -1 {
				s.curPos.next()
			} else {
				break
			}
			s.handler.Error("ERROR: unknown symbol", startPos, string(s.program[start]))
		} else {
			tok, continued := s.findToken(maxRightReg, startPos, pos, s.handler.Error, s.switchCondition)
			if !continued {
				return tok
			}
		}
	}

	return NewToken(EOPTag{}, s.curPos, s.curPos, "")
}
